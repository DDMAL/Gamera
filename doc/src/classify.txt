=====================
Gamera classifier API
=====================

Introduction
------------

For manual training of a classifier, you will generally want to use
the `interactive classifier GUI`__.  This document describes the
programming API that is used by scripts that make use of a classifier.

.. __: gui.html#interactive-classifier-window

Gamera supports segmentation-based image classification.  This means
that the page image is first segmented into individual connected
components (or glyphs).  Each of these glyphs has a number of features
generated from it.  These features (collectively called a "feature
vector") are then sent to a classifier which, using a database of
training data, identifies the glyph.

Interactive vs. Noniteractive classifiers
'''''''''''''''''''''''''''''''''''''''''

All classifiers in Gamera support the same core Classifier API (interface), so
they are interchangeable.  There is an important
distinction between two families of classifiers, however:

Interactive classifier
  An interactive classifier can have training examples added to it in
  real time, and the results used immediately to classify glyphs.
  Interactive classifiers are useful during the training process since
  the classifier can be "boot strapped" with a few examples and refined
  interactively. 

Noninteractive classifier
  Noninteractive classifiers take a complete database of
  training data and then create an optimised data structure for
  classification.  Because building that data structure can take a
  considerable amount of time, new training examples cannot be added
  on the fly.  In addition, noninteractive classifiers are
  serializable to binary classifier-specific file formats, which save
  and load much faster than the Gamera XML format.

Types of classifiers
''''''''''''''''''''

Within each of these families, different classifiers are available.
These "concrete" classifiers have additional methods specific to the
particular classifier type.  The currently implemented classifiers
are:

 - kNNInteractive_
     Interactive *k* nearest neighbor classifier.

 - kNNNonInteractive_
     Noninteractive *k* nearest neighbor classifier.  The weights of
     the dimensions can be optimised using a genetic algorithm.

     For a user-friendly way to perform GA optimization, consider the Biollante_
     tool in the Gamera GUI.

.. _Biollante: gui.html#classifier-optimization-biollante


Classifying images without a classifier
---------------------------------------

``id_name``
'''''''''''

When a glyph is classified, either by a manual classification or an
automatic classifier, its classification is stored in the member variable
``id_name``.  This variable is actually a list of possible
classifications, so that a classifier can return a number of different
possibilities with different confidences.  Each classification entry
is a tuple of the form (float *confidence*, string *name*).  The
confidence value is in the range 0.0 - 1.0, where 1.0 is most confident.

For example, if a symbol is most likely a lower-case *b*, but might
also be a lower-case *d*, its ``id_name`` variable might be:

.. code:: Python
  
  [(0.8, 'lower.b'), (0.2, 'lower.d')]

``classification_state``
''''''''''''''''''''''''

How a glyph was classified is managed by the ``classification_state``
member variable.  It can be one of the following values:

  +----------+--------------+-----------------------------------------------------+
  | Color    | Constant     | Description                                         |
  +==========+==============+=====================================================+
  | |UColor| | UNCLASSIFIED | The connected component is completely unclassified. |
  | (white)  |              |                                                     |
  +----------+--------------+-----------------------------------------------------+
  | |AColor| | AUTOMATIC    | The connected component was classified by the       | 
  | (red)    |              | automatic classifier using training data.           |
  +----------+--------------+-----------------------------------------------------+
  | |HColor| | HEURISTIC    | The connected component was classified by some      |
  | (yellow) |              | heuristic (non-exemplar-based) process.             |
  +----------+--------------+-----------------------------------------------------+
  | |MColor| | MANUAL       | The connected component was classified by a human.  |
  | (green)  |              |                                                     |
  +----------+--------------+-----------------------------------------------------+

.. |UColor| image:: images/unclassified_color.png
.. |AColor| image:: images/autoclassified_color.png
.. |HColor| image:: images/heuristicclassified_color.png
.. |MColor| image:: images/manualclassified_color.png

Methods
'''''''

Images have a number of methods for managing their classification
state.  Use of these methods is highly recommended over changing the
``id_name`` variable directly.  These methods are documented in the
`classification section of the plugin documentation`__.

.. __: plugins.html#classification

The classifier interface
------------------------

This section describes each method of the classifier interface.
They are divided into two categories:

Core
  Methods available to all classifiers

Interactive
  Methods available only to interactive classifiers

Core
''''

The following methods are available to all classifiers.

Initialization
``````````````

This is initialization

.. docstring:: gamera.classify NonInteractiveClassifier __init__ 

Classification
``````````````

The following methods deal with classifying glyphs on a individual level.

.. docstring:: gamera.classify NonInteractiveClassifier classify_glyph_automatic classify_list_automatic classify_and_update_list_automatic guess_glyph_automatic

Grouping
````````

Often, characters do not cleanly correspond to connected components.
For instance, broken or degraded printing may disconnect parts of a
character, or characters, such as *i* may always be made up of two
connected components.  The grouping algorithm is designed to deal with
those cases.  It attempts to group connected components with others
nearby in order to create groupings that are more like glyphs in the
database.  Needless to say, this approach is much slower than the
"one-connected-component-at-a-time" approach, but can produce
considerably better results on certain images.

To train for grouping, images corresponding to the entire character
must exist in the database.  For instance, in the Gamera GUI, one
would select both the dot and stem of a lower-case *i* and train it as
``_group.lower.i``.  This will join the two connected components into
a single image and then add it to the database.

The algorithm is described in more detail in our paper on `correcting
broken characters`__ (PDF).

.. __: http://dkc.jhu.edu/gamera/papers/droettboom_broken_characters.pdf

.. docstring:: gamera.classify NonInteractiveClassifier group_list_automatic group_and_update_list_automatic

Saving and loading
``````````````````

These functions deal with saving and loading the training data of the
classifier to/from the `Gamera XML format`__.

.. __: xml_format.html

.. note:: UNCLASSIFIED glyphs in the training data are ignored
   (neither saved or loaded).

.. docstring:: gamera.classify NonInteractiveClassifier to_xml to_xml_filename from_xml from_xml_filename merge_from_xml merge_from_xml_filename


Miscellaneous
`````````````

.. docstring:: gamera.classify NonInteractiveClassifier is_interactive get_glyphs set_glyphs merge_glyphs clear_glyphs

Interactive classifiers
'''''''''''''''''''''''

Classification
``````````````

.. docstring:: gamera.classify InteractiveClassifier classify_glyph_manual classify_list_manual classify_and_update_list_manual add_to_database remove_from_database

*k* Nearest Neighbor classifier
-------------------------------

The *k* Nearest Neighbor classifier is a concrete example of the
classifier API.  It adds some methods of its own.

``kNNNonInteractive`` has a number of advantages over
``kNNInteractive``:

- Each feature is normalized independently in the range (0, 1).  This
  reduces the bias toward features that generate large values, such as
  ``area``.  This normalization may change the classifications that
  the classifier makes, however.

- The weights of the features can be optimized using a genetic
  algorithm.  (See start_optimizing_).

  For a user-friendly way to perform GA optimization, consider the Biollante_
  tool in the Gamera GUI.

.. _Biollante: gui.html#classifier-optimization-biollante

- The training data can be serialized to a classifier-specific binary file
  format.  This format saves and loads much faster than the Gamera XML
  file format.

.. note:: 
   It is good practice to retain the XML
   file, since it is portable across platforms and to future versions of
   Gamera.  The binary format is not guaranteed to be portable.

All ``kNN`` classes
'''''''''''''''''''

Settings
````````

Settings are various parameters that control the behavior of the
classifier.

.. docstring:: gamera.knn _kNNBase save_settings load_settings

Serialization
`````````````
.. docstring:: gamera.knn _kNNBase serialize unserialize

Evaluation
''''''''''

.. docstring:: gamera.knn _kNNBase evaluate distance_from_images distance_between_images distance_matrix unique_distances

``kNNInteractive``
''''''''''''''''''

.. docstring:: gamera.knn kNNInteractive noninteractive_copy

``kNNNonInteractive``
'''''''''''''''''''''

Optimization
````````````

These methods pertain to optimizing the feature weights of the classifier using a
genetic algorithm.

.. docstring:: gamera.knn kNNNonInteractive start_optimizing stop_optimizing add_optimization_callback remove_optimization_callback

References
----------

.. [Holland1975] Holland, J. H. 1975. *Adaptation in natural and
   artifical systems.*  University of Michigan Press, Ann Arbor.
